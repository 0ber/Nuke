ImageManager.swift
	public let ImageManagerErrorDomain = "Nuke.ImageManagerErrorDomain"
	public let ImageManagerErrorCancelled = -1
	public let ImageManagerErrorUnknown = -2
	public struct ImageManagerConfiguration
	public var loader: ImageLoading
	public var cache: ImageMemoryCaching?
	public let configuration: ImageManagerConfiguration
	public init(configuration: ImageManagerConfiguration)
	public func imageLoader(imageLoader: ImageLoading, task: ImageTask, didUpdateProgressWithCompletedUnitCount completedUnitCount: Int64, totalUnitCount: Int64)
	public func imageLoader(imageLoader: ImageLoading, task: ImageTask, didCompleteWithImage image: Image?, error: ErrorType?, userInfo: Any?)
	public func isImageRequestKey(lhs: ImageRequestKey, equalToKey rhs: ImageRequestKey) -> Bool
ImageTask.swift
	public enum ImageTaskState
	case Suspended, Running, Cancelled, Completed
	case Suspended, Running, Cancelled, Completed
	case Suspended, Running, Cancelled, Completed
	case Suspended, Running, Cancelled, Completed
	public internal(set) var response: ImageResponse?
	public internal(set) var completedUnitCount: Int64 = 0
	public internal(set) var totalUnitCount: Int64 = 0
	public var hashValue: Int { return self.identifier }
	public init(request: ImageRequest, identifier: Int)
	public var fractionCompleted: Double
	public func ==(lhs: ImageTask, rhs: ImageTask) -> Bool
ImageResponse.swift
	case Success(Image, ImageResponseInfo)
	case Failure(ErrorType)
	public var image: Image?
	public var info: ImageResponseInfo?
	public var error: ErrorType?
	public var success: Bool
	public init(fastResponse: Bool, userInfo: Any? = nil)
ImageRequestKey.swift
	public protocol ImageRequestKeyOwner: class
	func isImageRequestKey(key: ImageRequestKey, equalToKey: ImageRequestKey) -> Bool
	public let request: ImageRequest
	public weak private(set) var owner: ImageRequestKeyOwner?
	public init(_ request: ImageRequest, owner: ImageRequestKeyOwner)
	public override var hash: Int
	public override func isEqual(other: AnyObject?) -> Bool
ImageManagerExtensions.swift
	func taskWithURL(URL: NSURL, completion: ImageTaskCompletion? = nil) -> ImageTask
	func taskWithRequest(request: ImageRequest, completion: ImageTaskCompletion?) -> ImageTask
ImageLoader.swift
	weak var manager: ImageLoadingManager? { get set }
	func resumeLoadingForTask(task: ImageTask)
	func suspendLoadingForTask(task: ImageTask)
	func cancelLoadingForTask(task: ImageTask)
	func isRequestCacheEquivalent(lhs: ImageRequest, toRequest rhs: ImageRequest) -> Bool
	func invalidate()
	func removeAllCachedImages()
	func imageLoader(imageLoader: ImageLoading, task: ImageTask, didUpdateProgressWithCompletedUnitCount completedUnitCount: Int64, totalUnitCount: Int64)
	func imageLoader(imageLoader: ImageLoading, task: ImageTask, didCompleteWithImage image: Image?, error: ErrorType?, userInfo: Any?)
	public struct ImageLoaderConfiguration
	public var dataLoader: ImageDataLoading
	public var decoder: ImageDecoding
	public class ImageLoaderDefaultDelegate: ImageLoaderDelegate
	public init() {}
	public weak var manager: ImageLoadingManager?
	public let configuration: ImageLoaderConfiguration
	public let delegate: ImageLoaderDelegate
	public func resumeLoadingForTask(task: ImageTask)
	public func suspendLoadingForTask(task: ImageTask)
	public func cancelLoadingForTask(task: ImageTask)
	public func isRequestCacheEquivalent(lhs: ImageRequest, toRequest rhs: ImageRequest) -> Bool
	public func invalidate()
	public func removeAllCachedImages()
	public func isImageRequestKey(lhs: ImageRequestKey, equalToKey rhs: ImageRequestKey) -> Bool
ImageDecoder.swift
	func imageWithData(data: NSData) -> Image?
	public init() {}
	public func imageWithData(data: NSData) -> Image?
	public var imageScale: CGFloat
	public let decoders: [ImageDecoding]
	public init(decoders: [ImageDecoding])
	public func imageWithData(data: NSData) -> Image?
ImageProcessor.swift
	public let processors: [ImageProcessing]
	public func processImage(input: Image) -> Image?
	public func ==(lhs: ImageProcessorComposition, rhs: ImageProcessorComposition) -> Bool
	public func processImage(image: Image) -> Image?
	public func ==(lhs: ImageDecompressor, rhs: ImageDecompressor) -> Bool
ImageDataLoader.swift
	func imageDataTaskWithRequest(request: ImageRequest, progressHandler: ImageDataLoadingProgressHandler, completionHandler: ImageDataLoadingCompletionHandler) -> NSURLSessionTask
	func invalidate()
	func removeAllCachedImages()
	public private(set) var session: NSURLSession!
	public init(sessionConfiguration: NSURLSessionConfiguration)
	public func imageDataTaskWithRequest(request: ImageRequest, progressHandler: ImageDataLoadingProgressHandler, completionHandler: ImageDataLoadingCompletionHandler) -> NSURLSessionTask
	public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData)
	public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?)
ImageMemoryCache.swift
	public protocol ImageMemoryCaching
	func cachedResponseForKey(key: ImageRequestKey) -> ImageCachedResponse?
	func storeResponse(response: ImageCachedResponse, forKey key: ImageRequestKey)
	func removeAllCachedImages()
	public class ImageCachedResponse
	public let image: Image
	public init(image: Image, userInfo: Any?)
	public let cache: NSCache
	public init(cache: NSCache)
	public func cachedResponseForKey(key: ImageRequestKey) -> ImageCachedResponse?
	public func storeResponse(response: ImageCachedResponse, forKey key: ImageRequestKey)
	public func costForImage(image: Image) -> Int
	public class func recommendedCacheTotalLimit() -> Int
	public func removeAllCachedImages()
